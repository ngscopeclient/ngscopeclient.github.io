<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ngscopeclient: AcceleratorBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ngscopeclient<span id="projectnumber">&#160;0.1-dev+51fbda87c</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classAcceleratorBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AcceleratorBuffer&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A buffer of memory which may be used by GPU acceleration.  
 <a href="classAcceleratorBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AcceleratorBuffer_8h_source.html">AcceleratorBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for AcceleratorBuffer&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classAcceleratorBuffer__coll__graph.png" border="0" usemap="#aAcceleratorBuffer_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aAcceleratorBuffer_3_01T_01_4_coll__map" id="aAcceleratorBuffer_3_01T_01_4_coll__map">
<area shape="rect" title="A buffer of memory which may be used by GPU acceleration." alt="" coords="5,109,180,136"/>
<area shape="rect" href="classAlignedAllocator.html" title=" " alt="" coords="15,5,171,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac69b4fd985fe1c5e2c990d9b2c089878"><td class="memItemLeft" align="right" valign="top"><a id="ac69b4fd985fe1c5e2c990d9b2c089878" name="ac69b4fd985fe1c5e2c990d9b2c089878"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#ac69b4fd985fe1c5e2c990d9b2c089878">MemoryAttributes</a> { <br />
&#160;&#160;<b>MEM_ATTRIB_CPU_SIDE</b> = 0x1
, <b>MEM_ATTRIB_GPU_SIDE</b> = 0x2
, <b>MEM_ATTRIB_CPU_REACHABLE</b> = 0x4
, <b>MEM_ATTRIB_GPU_REACHABLE</b> = 0x8
, <br />
&#160;&#160;<b>MEM_ATTRIB_CPU_FAST</b> = 0x10
, <b>MEM_ATTRIB_GPU_FAST</b> = 0x20
<br />
 }</td></tr>
<tr class="memdesc:ac69b4fd985fe1c5e2c990d9b2c089878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes that a memory buffer can have. <br /></td></tr>
<tr class="separator:ac69b4fd985fe1c5e2c990d9b2c089878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae128b32a6d406efedb71163f7775eb62"><td class="memItemLeft" align="right" valign="top"><a id="ae128b32a6d406efedb71163f7775eb62" name="ae128b32a6d406efedb71163f7775eb62"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a> { <br />
&#160;&#160;<b>MEM_TYPE_NULL</b> = 0
, <b>MEM_TYPE_CPU_PAGED</b>
, <b>MEM_TYPE_CPU_ONLY</b>
, <b>MEM_TYPE_CPU_DMA_CAPABLE</b>
, <br />
&#160;&#160;<b>MEM_TYPE_GPU_ONLY</b>
, <b>MEM_TYPE_GPU_DMA_CAPABLE</b>
<br />
 }</td></tr>
<tr class="memdesc:ae128b32a6d406efedb71163f7775eb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of memory buffer. <br /></td></tr>
<tr class="separator:ae128b32a6d406efedb71163f7775eb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd612f4e9e045d5be092a99a68249bf7"><td class="memItemLeft" align="right" valign="top"><a id="afd612f4e9e045d5be092a99a68249bf7" name="afd612f4e9e045d5be092a99a68249bf7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>UsageHint</b> { <b>HINT_NEVER</b>
, <b>HINT_UNLIKELY</b>
, <b>HINT_LIKELY</b>
 }</td></tr>
<tr class="separator:afd612f4e9e045d5be092a99a68249bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3dc555dcc8f50470466fe8075f7f38d"><td class="memItemLeft" align="right" valign="top"><a id="ac3dc555dcc8f50470466fe8075f7f38d" name="ac3dc555dcc8f50470466fe8075f7f38d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AcceleratorBuffer</b> (const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:ac3dc555dcc8f50470466fe8075f7f38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classAcceleratorBuffer.html" title="A buffer of memory which may be used by GPU acceleration.">AcceleratorBuffer</a> with no content. <br /></td></tr>
<tr class="separator:ac3dc555dcc8f50470466fe8075f7f38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f25e4ad39fdad1d93dffc0d9bcc5657"><td class="memItemLeft" align="right" valign="top"><a id="a3f25e4ad39fdad1d93dffc0d9bcc5657" name="a3f25e4ad39fdad1d93dffc0d9bcc5657"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a3f25e4ad39fdad1d93dffc0d9bcc5657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size of the container (may be smaller than what was allocated) <br /></td></tr>
<tr class="separator:a3f25e4ad39fdad1d93dffc0d9bcc5657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6437e1c1c60a5579d48ea8b9896fa129"><td class="memItemLeft" align="right" valign="top"><a id="a6437e1c1c60a5579d48ea8b9896fa129" name="a6437e1c1c60a5579d48ea8b9896fa129"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const</td></tr>
<tr class="memdesc:a6437e1c1c60a5579d48ea8b9896fa129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocated size of the container. <br /></td></tr>
<tr class="separator:a6437e1c1c60a5579d48ea8b9896fa129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe4fae111f0836068ba512d2d6405e9"><td class="memItemLeft" align="right" valign="top"><a id="a5fe4fae111f0836068ba512d2d6405e9" name="a5fe4fae111f0836068ba512d2d6405e9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetCpuMemoryBytes</b> () const</td></tr>
<tr class="memdesc:a5fe4fae111f0836068ba512d2d6405e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total reserved CPU memory, in bytes. <br /></td></tr>
<tr class="separator:a5fe4fae111f0836068ba512d2d6405e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b53b2a0f248f5a24527d4bffacee08"><td class="memItemLeft" align="right" valign="top"><a id="ab9b53b2a0f248f5a24527d4bffacee08" name="ab9b53b2a0f248f5a24527d4bffacee08"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetGpuMemoryBytes</b> () const</td></tr>
<tr class="memdesc:ab9b53b2a0f248f5a24527d4bffacee08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total reserved GPU memory, in bytes. <br /></td></tr>
<tr class="separator:ab9b53b2a0f248f5a24527d4bffacee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066907af139322815b19acd656fa14f4"><td class="memItemLeft" align="right" valign="top"><a id="a066907af139322815b19acd656fa14f4" name="a066907af139322815b19acd656fa14f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a066907af139322815b19acd656fa14f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the container is empty. <br /></td></tr>
<tr class="separator:a066907af139322815b19acd656fa14f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1408f4f6558e81c2731cfc60c66fbc9c"><td class="memItemLeft" align="right" valign="top"><a id="a1408f4f6558e81c2731cfc60c66fbc9c" name="a1408f4f6558e81c2731cfc60c66fbc9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCpuBufferStale</b> () const</td></tr>
<tr class="memdesc:a1408f4f6558e81c2731cfc60c66fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the CPU-side buffer is stale. <br /></td></tr>
<tr class="separator:a1408f4f6558e81c2731cfc60c66fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd09cbb4a94913a64151e3528f886f"><td class="memItemLeft" align="right" valign="top"><a id="afbcd09cbb4a94913a64151e3528f886f" name="afbcd09cbb4a94913a64151e3528f886f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsGpuBufferStale</b> () const</td></tr>
<tr class="memdesc:afbcd09cbb4a94913a64151e3528f886f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the GPU-side buffer is stale. <br /></td></tr>
<tr class="separator:afbcd09cbb4a94913a64151e3528f886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3258a68264fccd3bdf600d3083698e28"><td class="memItemLeft" align="right" valign="top"><a id="a3258a68264fccd3bdf600d3083698e28" name="a3258a68264fccd3bdf600d3083698e28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasCpuBuffer</b> () const</td></tr>
<tr class="memdesc:a3258a68264fccd3bdf600d3083698e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is currently a CPU-side buffer. <br /></td></tr>
<tr class="separator:a3258a68264fccd3bdf600d3083698e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e82c9976bddc5cef7926ed9ffd421"><td class="memItemLeft" align="right" valign="top"><a id="aad3e82c9976bddc5cef7926ed9ffd421" name="aad3e82c9976bddc5cef7926ed9ffd421"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasGpuBuffer</b> () const</td></tr>
<tr class="memdesc:aad3e82c9976bddc5cef7926ed9ffd421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is currently a GPU-side buffer. <br /></td></tr>
<tr class="separator:aad3e82c9976bddc5cef7926ed9ffd421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f95dcd99d376e19c97d793d49ad95f8"><td class="memItemLeft" align="right" valign="top"><a id="a2f95dcd99d376e19c97d793d49ad95f8" name="a2f95dcd99d376e19c97d793d49ad95f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSingleSharedBuffer</b> () const</td></tr>
<tr class="memdesc:a2f95dcd99d376e19c97d793d49ad95f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object contains only a single buffer. <br /></td></tr>
<tr class="separator:a2f95dcd99d376e19c97d793d49ad95f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0c48947cbca5148679a9974a241976"><td class="memItemLeft" align="right" valign="top">vk::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#a5c0c48947cbca5148679a9974a241976">GetBuffer</a> ()</td></tr>
<tr class="memdesc:a5c0c48947cbca5148679a9974a241976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the preferred buffer for GPU-side access.  <a href="classAcceleratorBuffer.html#a5c0c48947cbca5148679a9974a241976">More...</a><br /></td></tr>
<tr class="separator:a5c0c48947cbca5148679a9974a241976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee894ecc62dd39ce767bae158366b758"><td class="memItemLeft" align="right" valign="top"><a id="aee894ecc62dd39ce767bae158366b758" name="aee894ecc62dd39ce767bae158366b758"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>GetCpuPointer</b> ()</td></tr>
<tr class="memdesc:aee894ecc62dd39ce767bae158366b758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the CPU-side buffer. <br /></td></tr>
<tr class="separator:aee894ecc62dd39ce767bae158366b758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bce9a2246e0d7dbb1c082040da57ace"><td class="memItemLeft" align="right" valign="top"><a id="a1bce9a2246e0d7dbb1c082040da57ace" name="a1bce9a2246e0d7dbb1c082040da57ace"></a>
vk::DescriptorBufferInfo&#160;</td><td class="memItemRight" valign="bottom"><b>GetBufferInfo</b> ()</td></tr>
<tr class="memdesc:a1bce9a2246e0d7dbb1c082040da57ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vk::DescriptorBufferInfo suitable for binding this object to. <br /></td></tr>
<tr class="separator:a1bce9a2246e0d7dbb1c082040da57ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d1a4b3d80ac5786e2a43aadb3a5f38"><td class="memItemLeft" align="right" valign="top"><a id="a61d1a4b3d80ac5786e2a43aadb3a5f38" name="a61d1a4b3d80ac5786e2a43aadb3a5f38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_t size)</td></tr>
<tr class="memdesc:a61d1a4b3d80ac5786e2a43aadb3a5f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the usable size of the container. <br /></td></tr>
<tr class="separator:a61d1a4b3d80ac5786e2a43aadb3a5f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af231191d6b1297f1fa06ba50b52ae5f9"><td class="memItemLeft" align="right" valign="top"><a id="af231191d6b1297f1fa06ba50b52ae5f9" name="af231191d6b1297f1fa06ba50b52ae5f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:af231191d6b1297f1fa06ba50b52ae5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container to be empty (but don't free memory) <br /></td></tr>
<tr class="separator:af231191d6b1297f1fa06ba50b52ae5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e351e951f6c7e8329a5666d8b82d157"><td class="memItemLeft" align="right" valign="top"><a id="a7e351e951f6c7e8329a5666d8b82d157" name="a7e351e951f6c7e8329a5666d8b82d157"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (size_t size)</td></tr>
<tr class="memdesc:a7e351e951f6c7e8329a5666d8b82d157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates buffers so that at least size elements of storage are available. <br /></td></tr>
<tr class="separator:a7e351e951f6c7e8329a5666d8b82d157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb25bef2adce71f2f36c7f02eb221d93"><td class="memItemLeft" align="right" valign="top"><a id="abb25bef2adce71f2f36c7f02eb221d93" name="abb25bef2adce71f2f36c7f02eb221d93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="memdesc:abb25bef2adce71f2f36c7f02eb221d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees unused memory so that m_size == m_capacity. <br /></td></tr>
<tr class="separator:abb25bef2adce71f2f36c7f02eb221d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e43acd00151ba545b5a361515e5abd"><td class="memItemLeft" align="right" valign="top"><a id="a09e43acd00151ba545b5a361515e5abd" name="a09e43acd00151ba545b5a361515e5abd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((noinline)) void CopyFrom(const <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a09e43acd00151ba545b5a361515e5abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies our content from another <a class="el" href="classAcceleratorBuffer.html" title="A buffer of memory which may be used by GPU acceleration.">AcceleratorBuffer</a>. <br /></td></tr>
<tr class="separator:a09e43acd00151ba545b5a361515e5abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8556a36db7fb551d76f731658cb6a6ff"><td class="memItemLeft" align="right" valign="top"><a id="a8556a36db7fb551d76f731658cb6a6ff" name="a8556a36db7fb551d76f731658cb6a6ff"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t i) const</td></tr>
<tr class="separator:a8556a36db7fb551d76f731658cb6a6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be6db720916b2b715a2b9a4a0f861f5"><td class="memItemLeft" align="right" valign="top"><a id="a6be6db720916b2b715a2b9a4a0f861f5" name="a6be6db720916b2b715a2b9a4a0f861f5"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t i)</td></tr>
<tr class="separator:a6be6db720916b2b715a2b9a4a0f861f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb94cd850a05383d75e05133e01ec45"><td class="memItemLeft" align="right" valign="top"><a id="a0cb94cd850a05383d75e05133e01ec45" name="a0cb94cd850a05383d75e05133e01ec45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (const T &amp;value)</td></tr>
<tr class="memdesc:a0cb94cd850a05383d75e05133e01ec45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the end of the container, allocating space if needed. <br /></td></tr>
<tr class="separator:a0cb94cd850a05383d75e05133e01ec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfe6a40c6a14fb4d3833c2505f948ec"><td class="memItemLeft" align="right" valign="top"><a id="a5dfe6a40c6a14fb4d3833c2505f948ec" name="a5dfe6a40c6a14fb4d3833c2505f948ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="memdesc:a5dfe6a40c6a14fb4d3833c2505f948ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last item in the container. <br /></td></tr>
<tr class="separator:a5dfe6a40c6a14fb4d3833c2505f948ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4908598198149618e743b759ee91973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#ab4908598198149618e743b759ee91973">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ab4908598198149618e743b759ee91973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new item at the beginning of the container. This is inefficient due to copying.  <a href="classAcceleratorBuffer.html#ab4908598198149618e743b759ee91973">More...</a><br /></td></tr>
<tr class="separator:ab4908598198149618e743b759ee91973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7067a5f01c1a26b35c166e50a7b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#a09c7067a5f01c1a26b35c166e50a7b53">pop_front</a> ()</td></tr>
<tr class="memdesc:a09c7067a5f01c1a26b35c166e50a7b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first item in the container.  <a href="classAcceleratorBuffer.html#a09c7067a5f01c1a26b35c166e50a7b53">More...</a><br /></td></tr>
<tr class="separator:a09c7067a5f01c1a26b35c166e50a7b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5777959bd1242d2a5ac2dbd7e4d37257"><td class="memItemLeft" align="right" valign="top"><a id="a5777959bd1242d2a5ac2dbd7e4d37257" name="a5777959bd1242d2a5ac2dbd7e4d37257"></a>
<a class="el" href="classAcceleratorBufferIterator.html">AcceleratorBufferIterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a5777959bd1242d2a5ac2dbd7e4d37257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d15cc2a89bc6e3d52b97441e1d98006"><td class="memItemLeft" align="right" valign="top"><a id="a0d15cc2a89bc6e3d52b97441e1d98006" name="a0d15cc2a89bc6e3d52b97441e1d98006"></a>
<a class="el" href="classAcceleratorBufferIterator.html">AcceleratorBufferIterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a0d15cc2a89bc6e3d52b97441e1d98006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8461791fa62a0f6dd4fc3d0654905fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#aa8461791fa62a0f6dd4fc3d0654905fc">SetCpuAccessHint</a> (UsageHint hint, bool reallocateImmediately=false)</td></tr>
<tr class="memdesc:aa8461791fa62a0f6dd4fc3d0654905fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a hint to the buffer on how often we expect to use it on the CPU in the future.  <a href="classAcceleratorBuffer.html#aa8461791fa62a0f6dd4fc3d0654905fc">More...</a><br /></td></tr>
<tr class="separator:aa8461791fa62a0f6dd4fc3d0654905fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f947bdc79cc23a008c3087a00c41ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#a3f947bdc79cc23a008c3087a00c41ac1">SetGpuAccessHint</a> (UsageHint hint, bool reallocateImmediately=false)</td></tr>
<tr class="memdesc:a3f947bdc79cc23a008c3087a00c41ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a hint to the buffer on how often we expect to use it on the GPU in the future.  <a href="classAcceleratorBuffer.html#a3f947bdc79cc23a008c3087a00c41ac1">More...</a><br /></td></tr>
<tr class="separator:a3f947bdc79cc23a008c3087a00c41ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c986c4670e44d25eb44ffc53b7a2ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#a36c986c4670e44d25eb44ffc53b7a2ad">MarkModifiedFromCpu</a> ()</td></tr>
<tr class="memdesc:a36c986c4670e44d25eb44ffc53b7a2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the CPU-side copy of the buffer as modified.  <a href="classAcceleratorBuffer.html#a36c986c4670e44d25eb44ffc53b7a2ad">More...</a><br /></td></tr>
<tr class="separator:a36c986c4670e44d25eb44ffc53b7a2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f59659e41f46f80c4fc8e4a42bef00d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#a1f59659e41f46f80c4fc8e4a42bef00d">MarkModifiedFromGpu</a> ()</td></tr>
<tr class="memdesc:a1f59659e41f46f80c4fc8e4a42bef00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the GPU-side copy of the buffer as modified.  <a href="classAcceleratorBuffer.html#a1f59659e41f46f80c4fc8e4a42bef00d">More...</a><br /></td></tr>
<tr class="separator:a1f59659e41f46f80c4fc8e4a42bef00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e74d6d5197483812cc004f263767a5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#a3e74d6d5197483812cc004f263767a5e">PrepareForCpuAccess</a> ()</td></tr>
<tr class="memdesc:a3e74d6d5197483812cc004f263767a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the buffer to be accessed from the CPU.  <a href="classAcceleratorBuffer.html#a3e74d6d5197483812cc004f263767a5e">More...</a><br /></td></tr>
<tr class="separator:a3e74d6d5197483812cc004f263767a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c7c569893ac1992d8768c35ad48b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#a88c7c569893ac1992d8768c35ad48b4b">PrepareForGpuAccess</a> (bool outputOnly=false)</td></tr>
<tr class="memdesc:a88c7c569893ac1992d8768c35ad48b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the buffer to be accessed from the GPU.  <a href="classAcceleratorBuffer.html#a88c7c569893ac1992d8768c35ad48b4b">More...</a><br /></td></tr>
<tr class="separator:a88c7c569893ac1992d8768c35ad48b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92643da744d1c68cbc59f98ee0b4bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#aa92643da744d1c68cbc59f98ee0b4bb5">PrepareForGpuAccessNonblocking</a> (bool outputOnly, vk::raii::CommandBuffer &amp;cmdBuf)</td></tr>
<tr class="memdesc:aa92643da744d1c68cbc59f98ee0b4bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the buffer to be accessed from the GPU.  <a href="classAcceleratorBuffer.html#aa92643da744d1c68cbc59f98ee0b4bb5">More...</a><br /></td></tr>
<tr class="separator:aa92643da744d1c68cbc59f98ee0b4bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf99d2be1334deb323207e342d2a6190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#abf99d2be1334deb323207e342d2a6190">FreeGpuBuffer</a> (bool dataLossOK=false)</td></tr>
<tr class="memdesc:abf99d2be1334deb323207e342d2a6190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the GPU-side buffer and underlying physical memory.  <a href="classAcceleratorBuffer.html#abf99d2be1334deb323207e342d2a6190">More...</a><br /></td></tr>
<tr class="separator:abf99d2be1334deb323207e342d2a6190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08c8f7a8d428d13a9c15fc3cd532035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#af08c8f7a8d428d13a9c15fc3cd532035">SetName</a> (std::string name)</td></tr>
<tr class="memdesc:af08c8f7a8d428d13a9c15fc3cd532035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name for this buffer.  <a href="classAcceleratorBuffer.html#af08c8f7a8d428d13a9c15fc3cd532035">More...</a><br /></td></tr>
<tr class="separator:af08c8f7a8d428d13a9c15fc3cd532035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a421bcb08de8ef387f01bbb689acdfb94"><td class="memItemLeft" align="right" valign="top"><a id="a421bcb08de8ef387f01bbb689acdfb94" name="a421bcb08de8ef387f01bbb689acdfb94"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>HostToDeviceTransferMemoryBarrier</b> (vk::raii::CommandBuffer &amp;cmdBuf)</td></tr>
<tr class="memdesc:a421bcb08de8ef387f01bbb689acdfb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a memory barrier for transferring data from host to device. <br /></td></tr>
<tr class="separator:a421bcb08de8ef387f01bbb689acdfb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a248f07884ae05372579508c570a128f7"><td class="memItemLeft" align="right" valign="top"><a id="a248f07884ae05372579508c570a128f7" name="a248f07884ae05372579508c570a128f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReachableFromCpu</b> (<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a> mt)</td></tr>
<tr class="memdesc:a248f07884ae05372579508c570a128f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer type can be reached from the CPU. <br /></td></tr>
<tr class="separator:a248f07884ae05372579508c570a128f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5319cab1b6d273240920a7246ce30a62"><td class="memItemLeft" align="right" valign="top"><a id="a5319cab1b6d273240920a7246ce30a62" name="a5319cab1b6d273240920a7246ce30a62"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReachableFromGpu</b> (<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a> mt)</td></tr>
<tr class="memdesc:a5319cab1b6d273240920a7246ce30a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer type can be reached from the GPU. <br /></td></tr>
<tr class="separator:a5319cab1b6d273240920a7246ce30a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff1778df2e11308cd42690882515493"><td class="memItemLeft" align="right" valign="top"><a id="abff1778df2e11308cd42690882515493" name="abff1778df2e11308cd42690882515493"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsFastFromCpu</b> (<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a> mt)</td></tr>
<tr class="memdesc:abff1778df2e11308cd42690882515493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer type is fast to access from the CPU. <br /></td></tr>
<tr class="separator:abff1778df2e11308cd42690882515493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882d5048cc9f950bdb29bd60dbf245c5"><td class="memItemLeft" align="right" valign="top"><a id="a882d5048cc9f950bdb29bd60dbf245c5" name="a882d5048cc9f950bdb29bd60dbf245c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsFastFromGpu</b> (<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a> mt)</td></tr>
<tr class="memdesc:a882d5048cc9f950bdb29bd60dbf245c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer type is fast to access from the GPU. <br /></td></tr>
<tr class="separator:a882d5048cc9f950bdb29bd60dbf245c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb3f83ee5e01ba2aee6256ff1dfd725"><td class="memItemLeft" align="right" valign="top"><a id="adcb3f83ee5e01ba2aee6256ff1dfd725" name="adcb3f83ee5e01ba2aee6256ff1dfd725"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((noinline)) void Reallocate(size_t size)</td></tr>
<tr class="memdesc:adcb3f83ee5e01ba2aee6256ff1dfd725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates the buffer so that it contains exactly size elements. <br /></td></tr>
<tr class="separator:adcb3f83ee5e01ba2aee6256ff1dfd725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0decc8423c922f9e15f4e805abec4a7"><td class="memItemLeft" align="right" valign="top"><a id="ac0decc8423c922f9e15f4e805abec4a7" name="ac0decc8423c922f9e15f4e805abec4a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyToCpu</b> ()</td></tr>
<tr class="memdesc:ac0decc8423c922f9e15f4e805abec4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the buffer contents from GPU to CPU and blocks until the transfer completes. <br /></td></tr>
<tr class="separator:ac0decc8423c922f9e15f4e805abec4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017d6c1fd953cf4ff891c519e33d99a9"><td class="memItemLeft" align="right" valign="top"><a id="a017d6c1fd953cf4ff891c519e33d99a9" name="a017d6c1fd953cf4ff891c519e33d99a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyToGpu</b> ()</td></tr>
<tr class="memdesc:a017d6c1fd953cf4ff891c519e33d99a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the buffer contents from CPU to GPU and blocks until the transfer completes. <br /></td></tr>
<tr class="separator:a017d6c1fd953cf4ff891c519e33d99a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab600af784be39811df9e2d653d3a8d2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#ab600af784be39811df9e2d653d3a8d2b">CopyToGpuNonblocking</a> (vk::raii::CommandBuffer &amp;cmdBuf)</td></tr>
<tr class="memdesc:ab600af784be39811df9e2d653d3a8d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the buffer contents from CPU to GPU without blocking on the CPU.  <a href="classAcceleratorBuffer.html#ab600af784be39811df9e2d653d3a8d2b">More...</a><br /></td></tr>
<tr class="separator:ab600af784be39811df9e2d653d3a8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f2f7bab4ec4c135996eeab26108de0"><td class="memItemLeft" align="right" valign="top"><a id="aa8f2f7bab4ec4c135996eeab26108de0" name="aa8f2f7bab4ec4c135996eeab26108de0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreeCpuBuffer</b> ()</td></tr>
<tr class="memdesc:aa8f2f7bab4ec4c135996eeab26108de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the CPU-side buffer and underlying physical memory. <br /></td></tr>
<tr class="separator:aa8f2f7bab4ec4c135996eeab26108de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafd452d50093101d6a02eeb783aadd1"><td class="memItemLeft" align="right" valign="top"><a id="adafd452d50093101d6a02eeb783aadd1" name="adafd452d50093101d6a02eeb783aadd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((noinline)) void AllocateCpuBuffer(size_t size)</td></tr>
<tr class="memdesc:adafd452d50093101d6a02eeb783aadd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer for CPU access. <br /></td></tr>
<tr class="separator:adafd452d50093101d6a02eeb783aadd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ea5cca1008ed5be94297795051c668"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAcceleratorBuffer.html#ac1ea5cca1008ed5be94297795051c668">__attribute__</a> ((noinline)) void FreeCpuPointer(T *ptr</td></tr>
<tr class="memdesc:ac1ea5cca1008ed5be94297795051c668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a CPU-side buffer.  <a href="classAcceleratorBuffer.html#ac1ea5cca1008ed5be94297795051c668">More...</a><br /></td></tr>
<tr class="separator:ac1ea5cca1008ed5be94297795051c668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148ccd4cc358dde9bf167d40a229e54"><td class="memItemLeft" align="right" valign="top"><a id="aa148ccd4cc358dde9bf167d40a229e54" name="aa148ccd4cc358dde9bf167d40a229e54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((noinline)) void UpdateGpuNames()</td></tr>
<tr class="memdesc:aa148ccd4cc358dde9bf167d40a229e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes our friendly name to the underlying Vulkan objects. <br /></td></tr>
<tr class="separator:aa148ccd4cc358dde9bf167d40a229e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3effcf67cba94be11731c929166d54"><td class="memItemLeft" align="right" valign="top"><a id="aaa3effcf67cba94be11731c929166d54" name="aaa3effcf67cba94be11731c929166d54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((noinline)) void UpdateCpuNames()</td></tr>
<tr class="memdesc:aaa3effcf67cba94be11731c929166d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes our friendly name to the underlying Vulkan objects. <br /></td></tr>
<tr class="separator:aaa3effcf67cba94be11731c929166d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af3851bdb73748ac2b79054c920517391"><td class="memItemLeft" align="right" valign="top"><a id="af3851bdb73748ac2b79054c920517391" name="af3851bdb73748ac2b79054c920517391"></a>
<a class="el" href="classAlignedAllocator.html">AlignedAllocator</a>&lt; T, 32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_cpuAllocator</b></td></tr>
<tr class="separator:af3851bdb73748ac2b79054c920517391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e38e3919e30719422fb7a05051cce1"><td class="memItemLeft" align="right" valign="top"><a id="a87e38e3919e30719422fb7a05051cce1" name="a87e38e3919e30719422fb7a05051cce1"></a>
<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_cpuMemoryType</b></td></tr>
<tr class="memdesc:a87e38e3919e30719422fb7a05051cce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the CPU-side buffer. <br /></td></tr>
<tr class="separator:a87e38e3919e30719422fb7a05051cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9273ea9486a1454cff61f6700abd0f67"><td class="memItemLeft" align="right" valign="top"><a id="a9273ea9486a1454cff61f6700abd0f67" name="a9273ea9486a1454cff61f6700abd0f67"></a>
<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_gpuMemoryType</b></td></tr>
<tr class="memdesc:a9273ea9486a1454cff61f6700abd0f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the GPU-side buffer. <br /></td></tr>
<tr class="separator:a9273ea9486a1454cff61f6700abd0f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c3fe1eb63ad30554aa7e7a13fafc2"><td class="memItemLeft" align="right" valign="top"><a id="a082c3fe1eb63ad30554aa7e7a13fafc2" name="a082c3fe1eb63ad30554aa7e7a13fafc2"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>m_cpuPtr</b></td></tr>
<tr class="memdesc:a082c3fe1eb63ad30554aa7e7a13fafc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU-side mapped pointer. <br /></td></tr>
<tr class="separator:a082c3fe1eb63ad30554aa7e7a13fafc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2b64231575d6c45a1b822f21f0ac40"><td class="memItemLeft" align="right" valign="top"><a id="a1e2b64231575d6c45a1b822f21f0ac40" name="a1e2b64231575d6c45a1b822f21f0ac40"></a>
std::unique_ptr&lt; vk::raii::DeviceMemory &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_cpuPhysMem</b></td></tr>
<tr class="memdesc:a1e2b64231575d6c45a1b822f21f0ac40"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU-side physical memory. <br /></td></tr>
<tr class="separator:a1e2b64231575d6c45a1b822f21f0ac40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a10082e833defc90c81a997e25c60a7"><td class="memItemLeft" align="right" valign="top"><a id="a3a10082e833defc90c81a997e25c60a7" name="a3a10082e833defc90c81a997e25c60a7"></a>
std::unique_ptr&lt; vk::raii::DeviceMemory &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_gpuPhysMem</b></td></tr>
<tr class="memdesc:a3a10082e833defc90c81a997e25c60a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU-side physical memory. <br /></td></tr>
<tr class="separator:a3a10082e833defc90c81a997e25c60a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f104fc0890165ae3f0880bdd4c6f3ea"><td class="memItemLeft" align="right" valign="top"><a id="a8f104fc0890165ae3f0880bdd4c6f3ea" name="a8f104fc0890165ae3f0880bdd4c6f3ea"></a>
std::unique_ptr&lt; vk::raii::Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_cpuBuffer</b></td></tr>
<tr class="memdesc:a8f104fc0890165ae3f0880bdd4c6f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer object for CPU-side memory. <br /></td></tr>
<tr class="separator:a8f104fc0890165ae3f0880bdd4c6f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062c1660134062ab87baab3bfd34fded"><td class="memItemLeft" align="right" valign="top"><a id="a062c1660134062ab87baab3bfd34fded" name="a062c1660134062ab87baab3bfd34fded"></a>
std::unique_ptr&lt; vk::raii::Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_gpuBuffer</b></td></tr>
<tr class="memdesc:a062c1660134062ab87baab3bfd34fded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer object for GPU-side memory. <br /></td></tr>
<tr class="separator:a062c1660134062ab87baab3bfd34fded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e4f2aa89055bb094236b4673df5d00"><td class="memItemLeft" align="right" valign="top"><a id="a68e4f2aa89055bb094236b4673df5d00" name="a68e4f2aa89055bb094236b4673df5d00"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_buffersAreSame</b></td></tr>
<tr class="memdesc:a68e4f2aa89055bb094236b4673df5d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we have only one piece of physical memory accessible from both sides. <br /></td></tr>
<tr class="separator:a68e4f2aa89055bb094236b4673df5d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8025a0d9e3b6f4fd29ccdfa8e5a0a5d"><td class="memItemLeft" align="right" valign="top"><a id="ac8025a0d9e3b6f4fd29ccdfa8e5a0a5d" name="ac8025a0d9e3b6f4fd29ccdfa8e5a0a5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_cpuPhysMemIsStale</b></td></tr>
<tr class="memdesc:ac8025a0d9e3b6f4fd29ccdfa8e5a0a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if m_cpuPtr contains stale data (m_gpuPhysMem has been modified and they point to different memory) <br /></td></tr>
<tr class="separator:ac8025a0d9e3b6f4fd29ccdfa8e5a0a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dd10e53eab69ee4b24e667025e80ef"><td class="memItemLeft" align="right" valign="top"><a id="a49dd10e53eab69ee4b24e667025e80ef" name="a49dd10e53eab69ee4b24e667025e80ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_gpuPhysMemIsStale</b></td></tr>
<tr class="memdesc:a49dd10e53eab69ee4b24e667025e80ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if m_gpuPhysMem contains stale data (m_cpuPtr has been modified and they point to different memory) <br /></td></tr>
<tr class="separator:a49dd10e53eab69ee4b24e667025e80ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9b327dca04344e2f50bb5360fff84f"><td class="memItemLeft" align="right" valign="top"><a id="aba9b327dca04344e2f50bb5360fff84f" name="aba9b327dca04344e2f50bb5360fff84f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_tempFileHandle</b></td></tr>
<tr class="memdesc:aba9b327dca04344e2f50bb5360fff84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">File handle used for MEM_TYPE_CPU_PAGED. <br /></td></tr>
<tr class="separator:aba9b327dca04344e2f50bb5360fff84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf997178641a099ebe746ecb80df4468"><td class="memItemLeft" align="right" valign="top"><a id="abf997178641a099ebe746ecb80df4468" name="abf997178641a099ebe746ecb80df4468"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_capacity</b></td></tr>
<tr class="memdesc:abf997178641a099ebe746ecb80df4468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the allocated memory space (may be larger than m_size) <br /></td></tr>
<tr class="separator:abf997178641a099ebe746ecb80df4468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c5af7b9d1e1359dc84ef91b03481d9"><td class="memItemLeft" align="right" valign="top"><a id="a23c5af7b9d1e1359dc84ef91b03481d9" name="a23c5af7b9d1e1359dc84ef91b03481d9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_size</b></td></tr>
<tr class="memdesc:a23c5af7b9d1e1359dc84ef91b03481d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the memory actually being used. <br /></td></tr>
<tr class="separator:a23c5af7b9d1e1359dc84ef91b03481d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf06f0b10459ff0d487db5b6c47b3f8"><td class="memItemLeft" align="right" valign="top"><a id="adcf06f0b10459ff0d487db5b6c47b3f8" name="adcf06f0b10459ff0d487db5b6c47b3f8"></a>
UsageHint&#160;</td><td class="memItemRight" valign="bottom"><b>m_cpuAccessHint</b></td></tr>
<tr class="memdesc:adcf06f0b10459ff0d487db5b6c47b3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hint about how likely future CPU access is. <br /></td></tr>
<tr class="separator:adcf06f0b10459ff0d487db5b6c47b3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f3af446e906f919680c9458ca5477f"><td class="memItemLeft" align="right" valign="top"><a id="a83f3af446e906f919680c9458ca5477f" name="a83f3af446e906f919680c9458ca5477f"></a>
UsageHint&#160;</td><td class="memItemRight" valign="bottom"><b>m_gpuAccessHint</b></td></tr>
<tr class="memdesc:a83f3af446e906f919680c9458ca5477f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hint about how likely future GPU access is. <br /></td></tr>
<tr class="separator:a83f3af446e906f919680c9458ca5477f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac218ae38ed7cbdcddca8da63f4c5f49f"><td class="memItemLeft" align="right" valign="top"><a id="ac218ae38ed7cbdcddca8da63f4c5f49f" name="ac218ae38ed7cbdcddca8da63f4c5f49f"></a>
<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>type</b></td></tr>
<tr class="separator:ac218ae38ed7cbdcddca8da63f4c5f49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e8a1cdfeee93c6f140bdd2edd42773"><td class="memItemLeft" align="right" valign="top"><a id="ae3e8a1cdfeee93c6f140bdd2edd42773" name="ae3e8a1cdfeee93c6f140bdd2edd42773"></a>
<a class="el" href="classAcceleratorBuffer.html#ae128b32a6d406efedb71163f7775eb62">MemoryType</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="separator:ae3e8a1cdfeee93c6f140bdd2edd42773"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class AcceleratorBuffer&lt; T &gt;</div><p >A buffer of memory which may be used by GPU acceleration. </p>
<p >At any given point in time the buffer may exist as a single copy on the CPU, a single copy on the GPU, or mirrored buffers on both sides.</p>
<p >Hints can be provided to the buffer about future usage patterns to optimize storage location for best performance.</p>
<p >This buffer generally provides std::vector semantics, but does <em>not</em> initialize memory or call constructors on elements when calling <a class="el" href="classAcceleratorBuffer.html#a61d1a4b3d80ac5786e2a43aadb3a5f38" title="Change the usable size of the container.">resize()</a> or <a class="el" href="classAcceleratorBuffer.html#a7e351e951f6c7e8329a5666d8b82d157" title="Reallocates buffers so that at least size elements of storage are available.">reserve()</a> unless the element type is not trivially copyable. All locations not explicitly written to have undefined values. Most notably, allocated buffer space between size() and <a class="el" href="classAcceleratorBuffer.html#a6437e1c1c60a5579d48ea8b9896fa129" title="Returns the allocated size of the container.">capacity()</a> is undefined and its value may not be coherent between CPU and GPU view of the buffer.</p>
<p >If the element type is not trivially copyable, the data cannot be shared with the GPU. This class still supports non-trivially-copyable types as a convenience for working with waveforms on the CPU. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac1ea5cca1008ed5be94297795051c668" name="ac1ea5cca1008ed5be94297795051c668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ea5cca1008ed5be94297795051c668">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(noinline)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a CPU-side buffer. </p>
<p >An explicit type is passed here because if we're reallocating we might change memory type. By this point AllocateCpuBuffer() has been called so m_cpuMemoryType points to the type of the new buffer, not the one we're getting rid of. </p>

</div>
</div>
<a id="ab600af784be39811df9e2d653d3a8d2b" name="ab600af784be39811df9e2d653d3a8d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab600af784be39811df9e2d653d3a8d2b">&#9670;&nbsp;</a></span>CopyToGpuNonblocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::CopyToGpuNonblocking </td>
          <td>(</td>
          <td class="paramtype">vk::raii::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the buffer contents from CPU to GPU without blocking on the CPU. </p>
<p >Inserts a memory barrier to ensure that GPU-side access is synchronized. </p>

</div>
</div>
<a id="abf99d2be1334deb323207e342d2a6190" name="abf99d2be1334deb323207e342d2a6190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf99d2be1334deb323207e342d2a6190">&#9670;&nbsp;</a></span>FreeGpuBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::FreeGpuBuffer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dataLossOK</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the GPU-side buffer and underlying physical memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataLossOK</td><td>True if we do not intend to use the contents of this buffer again (and thus it's OK to remove the only copy of the data) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c0c48947cbca5148679a9974a241976" name="a5c0c48947cbca5148679a9974a241976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0c48947cbca5148679a9974a241976">&#9670;&nbsp;</a></span>GetBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Buffer <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::GetBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the preferred buffer for GPU-side access. </p>
<p >This is the GPU buffer if we have one, otherwise the CPU buffer. </p>

</div>
</div>
<a id="a36c986c4670e44d25eb44ffc53b7a2ad" name="a36c986c4670e44d25eb44ffc53b7a2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c986c4670e44d25eb44ffc53b7a2ad">&#9670;&nbsp;</a></span>MarkModifiedFromCpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::MarkModifiedFromCpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the CPU-side copy of the buffer as modified. </p>
<p >If the CPU and GPU pointers point to different memory, this makes the GPU-side copy stale. </p>

</div>
</div>
<a id="a1f59659e41f46f80c4fc8e4a42bef00d" name="a1f59659e41f46f80c4fc8e4a42bef00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f59659e41f46f80c4fc8e4a42bef00d">&#9670;&nbsp;</a></span>MarkModifiedFromGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::MarkModifiedFromGpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the GPU-side copy of the buffer as modified. </p>
<p >If the CPU and GPU pointers point to different memory, this makes the CPU-side copy stale. </p>

</div>
</div>
<a id="a09c7067a5f01c1a26b35c166e50a7b53" name="a09c7067a5f01c1a26b35c166e50a7b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c7067a5f01c1a26b35c166e50a7b53">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first item in the container. </p>
<p >TODO: GPU implementation of this? </p>

</div>
</div>
<a id="a3e74d6d5197483812cc004f263767a5e" name="a3e74d6d5197483812cc004f263767a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e74d6d5197483812cc004f263767a5e">&#9670;&nbsp;</a></span>PrepareForCpuAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::PrepareForCpuAccess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares the buffer to be accessed from the CPU. </p>
<p >This MUST be called prior to accessing the CPU-side buffer to ensure that m_cpuPtr is valid and up to date. </p>

</div>
</div>
<a id="a88c7c569893ac1992d8768c35ad48b4b" name="a88c7c569893ac1992d8768c35ad48b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c7c569893ac1992d8768c35ad48b4b">&#9670;&nbsp;</a></span>PrepareForGpuAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::PrepareForGpuAccess </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outputOnly</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares the buffer to be accessed from the GPU. </p>
<p >This MUST be called prior to accessing the GPU-side buffer to ensure that m_gpuPhysMem is valid and up to date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputOnly</td><td>True if the buffer is output-only for the shader, so there's no need to copy anything to the GPU even if data is stale. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa92643da744d1c68cbc59f98ee0b4bb5" name="aa92643da744d1c68cbc59f98ee0b4bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92643da744d1c68cbc59f98ee0b4bb5">&#9670;&nbsp;</a></span>PrepareForGpuAccessNonblocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::PrepareForGpuAccessNonblocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outputOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::raii::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>cmdBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares the buffer to be accessed from the GPU. </p>
<p >This MUST be called prior to accessing the GPU-side buffer to ensure that m_gpuPhysMem is valid and up to date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputOnly</td><td>True if the buffer is output-only for the shader, so there's no need to copy anything to the GPU even if data is stale. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4908598198149618e743b759ee91973" name="ab4908598198149618e743b759ee91973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4908598198149618e743b759ee91973">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new item at the beginning of the container. This is inefficient due to copying. </p>
<p >TODO: GPU implementation of this? </p>

</div>
</div>
<a id="aa8461791fa62a0f6dd4fc3d0654905fc" name="aa8461791fa62a0f6dd4fc3d0654905fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8461791fa62a0f6dd4fc3d0654905fc">&#9670;&nbsp;</a></span>SetCpuAccessHint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::SetCpuAccessHint </td>
          <td>(</td>
          <td class="paramtype">UsageHint&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reallocateImmediately</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a hint to the buffer on how often we expect to use it on the CPU in the future. </p>
<p >If reallocateImmediately is set, the buffer is reallocated with the specified settings to fit the current buffer size (shrinking to fit if needed) </p>

</div>
</div>
<a id="a3f947bdc79cc23a008c3087a00c41ac1" name="a3f947bdc79cc23a008c3087a00c41ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f947bdc79cc23a008c3087a00c41ac1">&#9670;&nbsp;</a></span>SetGpuAccessHint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::SetGpuAccessHint </td>
          <td>(</td>
          <td class="paramtype">UsageHint&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reallocateImmediately</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a hint to the buffer on how often we expect to use it on the GPU in the future. </p>
<p >If reallocateImmediately is set, the buffer is reallocated with the specified settings to fit the current buffer size (shrinking to fit if needed) </p>

</div>
</div>
<a id="af08c8f7a8d428d13a9c15fc3cd532035" name="af08c8f7a8d428d13a9c15fc3cd532035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08c8f7a8d428d13a9c15fc3cd532035">&#9670;&nbsp;</a></span>SetName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAcceleratorBuffer.html">AcceleratorBuffer</a>&lt; T &gt;::SetName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the debug name for this buffer. </p>
<p >The name can be queried by m_name in a debugger. If VK_EXT_debug_utils is active, the name will also be attached to the Vulkan object handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/scopehal/<a class="el" href="AcceleratorBuffer_8h_source.html">AcceleratorBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
